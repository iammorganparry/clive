#!/usr/bin/env bash
# Post-install setup for the Clive Memory plugin.
# Prompts for configuration and builds the MCP binary if Go is available.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BIN_DIR="${SCRIPT_DIR}/bin"
ENV_FILE="${SCRIPT_DIR}/env"
MCP_FILE="${SCRIPT_DIR}/.mcp.json"
MEMORY_SERVER="${CLIVE_MEMORY_URL:-https://memory-production-23b6.up.railway.app}"
API_KEY="${CLIVE_MEMORY_API_KEY:-}"
NAMESPACE="${CLIVE_NAMESPACE:-}"

# Colors
if [ -t 1 ]; then
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  NC='\033[0m'
else
  GREEN='' YELLOW='' BLUE='' NC=''
fi

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
warn()  { echo -e "${YELLOW}[warn]${NC}  $*"; }

# ── Prerequisites ────────────────────────────────────────────────────────────

command -v jq   >/dev/null 2>&1 || { warn "jq not found — install it: brew install jq / apt install jq"; exit 0; }
command -v curl >/dev/null 2>&1 || { warn "curl not found — hooks require curl"; exit 0; }

# ── Configuration ────────────────────────────────────────────────────────────

if [ -t 0 ]; then
  echo ""

  # API key
  if [ -z "$API_KEY" ]; then
    info "API key authenticates with the shared memory server."
    printf "  Enter memory server API key (or leave blank for no auth): "
    read -r API_KEY_INPUT
    API_KEY="${API_KEY_INPUT:-}"
  fi

  # Namespace
  if [ -z "$NAMESPACE" ]; then
    echo ""
    info "Namespace isolates your memories from other users on the same server."
    info "Leave blank for the default namespace (single-user or personal use)."
    printf "  Enter namespace (e.g. team-alpha, your-name) [default]: "
    read -r NAMESPACE_INPUT
    NAMESPACE="${NAMESPACE_INPUT:-}"
  fi
fi

if [ -n "$NAMESPACE" ]; then
  if ! echo "$NAMESPACE" | grep -qE '^[a-zA-Z0-9_-]{1,64}$'; then
    warn "Invalid namespace '${NAMESPACE}' — using default"
    NAMESPACE=""
  else
    ok "Namespace: ${NAMESPACE}"
  fi
else
  ok "Namespace: default (no isolation)"
fi

if [ -n "$API_KEY" ]; then
  ok "API key: configured"
fi

# ── Write env file ───────────────────────────────────────────────────────────

info "Writing config to ${ENV_FILE}"

cat > "$ENV_FILE" <<ENVEOF
# Clive Memory — plugin configuration
# Generated by setup.sh — edit freely, sourced by hooks on every invocation.
CLIVE_MEMORY_URL="${MEMORY_SERVER}"
ENVEOF

if [ -n "$API_KEY" ]; then
  echo "CLIVE_MEMORY_API_KEY=\"${API_KEY}\"" >> "$ENV_FILE"
fi

if [ -n "$NAMESPACE" ]; then
  echo "CLIVE_NAMESPACE=\"${NAMESPACE}\"" >> "$ENV_FILE"
fi

chmod 600 "$ENV_FILE"
ok "Config written"

# ── Update .mcp.json with configured env ─────────────────────────────────────

info "Updating MCP server config..."

MCP_ENV=$(jq -n --arg url "$MEMORY_SERVER" '{"MEMORY_SERVER_URL": $url}')
if [ -n "$API_KEY" ]; then
  MCP_ENV=$(echo "$MCP_ENV" | jq --arg key "$API_KEY" '. + {"CLIVE_MEMORY_API_KEY": $key}')
fi
if [ -n "$NAMESPACE" ]; then
  MCP_ENV=$(echo "$MCP_ENV" | jq --arg ns "$NAMESPACE" '. + {"CLIVE_NAMESPACE": $ns}')
fi

jq -n --arg bin '${CLAUDE_PLUGIN_ROOT}/bin/memory-mcp' --argjson env "$MCP_ENV" '{
  "mcpServers": {
    "clive-memory": {
      "command": $bin,
      "env": $env
    }
  }
}' > "$MCP_FILE"

ok "Updated .mcp.json"

# ── Build MCP binary ─────────────────────────────────────────────────────────

if command -v go >/dev/null 2>&1; then
  GO_VERSION=$(go version | grep -oE 'go[0-9]+\.[0-9]+' | head -1 | sed 's/go//')
  GO_MAJOR=$(echo "$GO_VERSION" | cut -d. -f1)
  GO_MINOR=$(echo "$GO_VERSION" | cut -d. -f2)

  if [ "$GO_MAJOR" -ge 1 ] && [ "$GO_MINOR" -ge 21 ]; then
    info "Building MCP server binary..."
    mkdir -p "$BIN_DIR"

    if (cd "${SCRIPT_DIR}/mcp" && go build -o "${BIN_DIR}/memory-mcp" . 2>&1); then
      chmod +x "${BIN_DIR}/memory-mcp"
      ok "Built MCP binary at ${BIN_DIR}/memory-mcp"
    else
      warn "MCP build failed — hooks will still work without MCP tools"
    fi
  else
    warn "Go ${GO_VERSION} found but 1.21+ required — skipping MCP build"
  fi
else
  warn "Go not found — MCP binary not built (hooks still work without it)"
fi

# ── Health check ─────────────────────────────────────────────────────────────

info "Checking memory server at ${MEMORY_SERVER}..."

HEALTH_ARGS=(-s --max-time 5)
if [ -n "$API_KEY" ]; then
  HEALTH_ARGS+=(-H "Authorization: Bearer ${API_KEY}")
fi

HEALTH=$(curl "${HEALTH_ARGS[@]}" "${MEMORY_SERVER}/health" 2>/dev/null) || HEALTH=""
STATUS=$(echo "$HEALTH" | jq -r '.status // empty' 2>/dev/null) || STATUS=""

if [ "$STATUS" = "ok" ] || [ "$STATUS" = "degraded" ]; then
  ok "Memory server healthy (status: ${STATUS})"
else
  warn "Memory server not reachable at ${MEMORY_SERVER} — hooks will retry each session"
fi

echo ""
ok "Setup complete. Restart Claude Code to activate memory hooks."
if [ -n "$NAMESPACE" ]; then
  echo "  Your memories are isolated to namespace: ${NAMESPACE}"
fi
echo "  To change config later, edit: ${ENV_FILE}"
