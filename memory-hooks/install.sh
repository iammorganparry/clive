#!/usr/bin/env bash
# Clive Memory Hooks — One-command installer
# Installs Claude Code hooks and optional MCP server for shared memory.
#
# Usage:
#   bash install.sh                              # Interactive — prompts for config
#   CLIVE_NAMESPACE=team-alpha bash install.sh   # Pre-set namespace
#   CLIVE_MEMORY_API_KEY=xxx bash install.sh     # Pre-set API key
#   CLIVE_MEMORY_URL=http://localhost:8741 bash install.sh  # Use local server
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_DIR="${HOME}/.claude/memory"
HOOKS_DIR="${INSTALL_DIR}/hooks"
BIN_DIR="${INSTALL_DIR}/bin"
SETTINGS_FILE="${HOME}/.claude/settings.json"
MEMORY_SERVER="${CLIVE_MEMORY_URL:-https://memory-production-23b6.up.railway.app}"
NAMESPACE="${CLIVE_NAMESPACE:-}"
API_KEY="${CLIVE_MEMORY_API_KEY:-}"
ENV_FILE="${INSTALL_DIR}/env"

# Colors (disable if not a terminal)
if [ -t 1 ]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
warn()  { echo -e "${YELLOW}[warn]${NC}  $*"; }
fail()  { echo -e "${RED}[fail]${NC}  $*"; exit 1; }

# ── Step 1: Check prerequisites ─────────────────────────────────────────────

info "Checking prerequisites..."

command -v jq   >/dev/null 2>&1 || fail "jq is required but not installed. Install it: brew install jq / apt install jq"
command -v curl >/dev/null 2>&1 || fail "curl is required but not installed."

ok "jq and curl found"

# ── Step 1b: Configuration ────────────────────────────────────────────────────

if [ -t 0 ]; then
  echo ""

  # API key
  if [ -z "$API_KEY" ]; then
    info "API key authenticates with the shared memory server."
    printf "  Enter memory server API key (or leave blank for no auth): "
    read -r API_KEY_INPUT
    API_KEY="${API_KEY_INPUT:-}"
  fi

  # Namespace — auto-generate from username if not set
  if [ -z "$NAMESPACE" ]; then
    # Generate default from system username (sanitized to valid chars)
    DEFAULT_NAMESPACE=$(whoami | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g' | cut -c1-64)
    echo ""
    info "Namespace isolates your memories from other users on the same server."
    printf "  Enter namespace [${DEFAULT_NAMESPACE}]: "
    read -r NAMESPACE_INPUT
    NAMESPACE="${NAMESPACE_INPUT:-$DEFAULT_NAMESPACE}"
  fi
fi

# Validate: alphanumeric, hyphens, underscores, max 64 chars
if ! echo "$NAMESPACE" | grep -qE '^[a-zA-Z0-9_-]{1,64}$'; then
  fail "Invalid namespace '${NAMESPACE}': must be alphanumeric, hyphens, underscores only (max 64 chars)"
fi
ok "Namespace: ${NAMESPACE}"

if [ -n "$API_KEY" ]; then
  ok "API key: configured"
fi

# ── Step 2: Copy hooks ──────────────────────────────────────────────────────

info "Installing hooks to ${HOOKS_DIR}/"

mkdir -p "$HOOKS_DIR"

HOOK_FILES=(
  lib.sh
  session-start.sh
  user-prompt-submit.sh
  pre-tool-use.sh
  pre-compact.sh
  stop.sh
  post-tool-use.sh
  remember.sh
  promote.sh
  supersede.sh
)

for f in "${HOOK_FILES[@]}"; do
  cp "${SCRIPT_DIR}/hooks/${f}" "${HOOKS_DIR}/${f}"
  chmod +x "${HOOKS_DIR}/${f}"
done

ok "Installed ${#HOOK_FILES[@]} hook scripts"

# ── Step 2b: Write env file ──────────────────────────────────────────────────
# All config lives in ~/.claude/memory/env — hooks source this automatically.
# No shell profile changes needed.

info "Writing config to ${ENV_FILE}"

cat > "$ENV_FILE" <<ENVEOF
# Clive Memory — Claude Code configuration
# Generated by install.sh — edit freely, sourced by hooks on every invocation.
CLIVE_MEMORY_URL="${MEMORY_SERVER}"
ENVEOF

if [ -n "$API_KEY" ]; then
  echo "CLIVE_MEMORY_API_KEY=\"${API_KEY}\"" >> "$ENV_FILE"
fi

if [ -n "$NAMESPACE" ]; then
  echo "CLIVE_NAMESPACE=\"${NAMESPACE}\"" >> "$ENV_FILE"
fi

chmod 600 "$ENV_FILE"  # restrict read — may contain API key
ok "Config written to ${ENV_FILE}"

# ── Step 3: Build MCP binary (optional) ─────────────────────────────────────

MCP_BUILT=false

if command -v go >/dev/null 2>&1; then
  GO_VERSION=$(go version | grep -oE 'go[0-9]+\.[0-9]+' | head -1 | sed 's/go//')
  GO_MAJOR=$(echo "$GO_VERSION" | cut -d. -f1)
  GO_MINOR=$(echo "$GO_VERSION" | cut -d. -f2)

  if [ "$GO_MAJOR" -ge 1 ] && [ "$GO_MINOR" -ge 21 ]; then
    info "Building MCP server binary..."
    mkdir -p "$BIN_DIR"

    if (cd "${SCRIPT_DIR}/mcp" && go build -o "${BIN_DIR}/memory-mcp" . 2>&1); then
      chmod +x "${BIN_DIR}/memory-mcp"
      MCP_BUILT=true
      ok "Built MCP binary at ${BIN_DIR}/memory-mcp"
    else
      warn "MCP build failed — hooks will still work without it"
    fi
  else
    warn "Go ${GO_VERSION} found but 1.21+ required for MCP build — skipping (hooks still work)"
  fi
else
  warn "Go not found — skipping MCP binary build (hooks still work)"
fi

# ── Step 4: Merge into Claude Code settings ──────────────────────────────────

info "Configuring Claude Code settings..."

mkdir -p "$(dirname "$SETTINGS_FILE")"

# Start with existing settings or empty object
if [ -f "$SETTINGS_FILE" ]; then
  EXISTING=$(cat "$SETTINGS_FILE")
else
  EXISTING='{}'
fi

# Build hook entries
HOOKS_JSON=$(jq -n \
  --arg hooks_dir "$HOOKS_DIR" \
  '{
    "hooks": {
      "SessionStart": [
        {
          "type": "command",
          "command": "bash " + $hooks_dir + "/session-start.sh"
        }
      ],
      "UserPromptSubmit": [
        {
          "type": "command",
          "command": "bash " + $hooks_dir + "/user-prompt-submit.sh"
        }
      ],
      "PreToolUse": [
        {
          "matcher": "Write|Edit|MultiEdit",
          "type": "command",
          "command": "bash " + $hooks_dir + "/pre-tool-use.sh"
        }
      ],
      "PreCompact": [
        {
          "type": "command",
          "command": "bash " + $hooks_dir + "/pre-compact.sh"
        }
      ],
      "Stop": [
        {
          "type": "command",
          "command": "bash " + $hooks_dir + "/stop.sh"
        }
      ],
      "PostToolUse": [
        {
          "type": "command",
          "command": "bash " + $hooks_dir + "/post-tool-use.sh"
        }
      ]
    }
  }')

# Build MCP entry if binary was built
MCP_JSON='{}'
if [ "$MCP_BUILT" = true ]; then
  # Build env object for the MCP server with all configured values
  MCP_ENV=$(jq -n --arg url "$MEMORY_SERVER" '{"MEMORY_SERVER_URL": $url}')
  if [ -n "$API_KEY" ]; then
    MCP_ENV=$(echo "$MCP_ENV" | jq --arg key "$API_KEY" '. + {"CLIVE_MEMORY_API_KEY": $key}')
  fi
  if [ -n "$NAMESPACE" ]; then
    MCP_ENV=$(echo "$MCP_ENV" | jq --arg ns "$NAMESPACE" '. + {"CLIVE_NAMESPACE": $ns}')
  fi

  MCP_JSON=$(jq -n \
    --arg bin "${BIN_DIR}/memory-mcp" \
    --argjson env "$MCP_ENV" \
    '{
      "mcpServers": {
        "clive-memory": {
          "command": $bin,
          "env": $env
        }
      }
    }')
fi

# Deep-merge: existing * hooks * mcp (existing values preserved, new ones added)
# For hooks: merge arrays by appending new entries that don't already exist
MERGED=$(echo "$EXISTING" | jq --argjson hooks "$HOOKS_JSON" --argjson mcp "$MCP_JSON" '
  # Deep merge function for hooks: append new hook commands if not already present
  def merge_hook_arrays($new):
    if . == null then $new
    elif $new == null then .
    else
      # For each new entry, add it only if its command is not already in the array
      reduce ($new[]) as $entry (
        .;
        if any(.[]; .command == $entry.command) then . else . + [$entry] end
      )
    end;

  # Merge hooks
  .hooks = (
    (.hooks // {}) as $existing_hooks |
    ($hooks.hooks // {}) as $new_hooks |
    $existing_hooks * (
      $new_hooks | to_entries | reduce .[] as $e (
        {};
        . + { ($e.key): (($existing_hooks[$e.key] // []) | merge_hook_arrays($e.value)) }
      )
    )
  ) |

  # Merge mcpServers
  if $mcp.mcpServers then
    .mcpServers = ((.mcpServers // {}) * $mcp.mcpServers)
  else . end
')

echo "$MERGED" | jq '.' > "$SETTINGS_FILE"

ok "Updated ${SETTINGS_FILE}"

# ── Step 5: Health check ─────────────────────────────────────────────────────

info "Checking memory server at ${MEMORY_SERVER}..."

HEALTH=$(curl -s --max-time 5 "${MEMORY_SERVER}/health" 2>/dev/null) || HEALTH=""
STATUS=$(echo "$HEALTH" | jq -r '.status // empty' 2>/dev/null) || STATUS=""

if [ "$STATUS" = "ok" ] || [ "$STATUS" = "degraded" ]; then
  ok "Memory server is healthy (status: ${STATUS})"
else
  warn "Memory server not reachable — hooks will retry each session"
fi

# ── Summary ──────────────────────────────────────────────────────────────────

echo ""
echo -e "${GREEN}Installation complete!${NC}"
echo ""
echo "  Hooks installed:  ${HOOKS_DIR}/ (${#HOOK_FILES[@]} scripts)"
if [ "$MCP_BUILT" = true ]; then
  echo "  MCP binary:       ${BIN_DIR}/memory-mcp"
fi
echo "  Config:            ${ENV_FILE}"
echo "  Settings updated:  ${SETTINGS_FILE}"
echo "  Memory server:     ${MEMORY_SERVER}"
if [ -n "$NAMESPACE" ]; then
  echo "  Namespace:         ${NAMESPACE}"
fi
echo ""
echo "  Restart Claude Code to activate. Memory hooks will:"
echo "    - Inject relevant memories at session start"
echo "    - Search for context on each prompt"
echo "    - Warn about known gotchas before file edits"
echo "    - Save session summaries on exit"
echo ""
echo "  Agent helpers (available inside Claude Code sessions):"
echo "    bash ${HOOKS_DIR}/remember.sh TYPE \"content\" \"tags\" [confidence]"
echo "    bash ${HOOKS_DIR}/promote.sh MEMORY_ID [helpful|promoted|cited]"
echo "    bash ${HOOKS_DIR}/supersede.sh OLD_ID NEW_ID"
echo ""
if [ "$MCP_BUILT" = true ]; then
  echo "  MCP tools (available as Claude Code tools):"
  echo "    memory_search_index, memory_get, memory_store,"
  echo "    memory_impact, memory_supersede, memory_timeline"
  echo ""
fi
echo "  To change config later, edit: ${ENV_FILE}"
echo ""
echo "  To uninstall:"
echo "    bash ${SCRIPT_DIR}/uninstall.sh"
