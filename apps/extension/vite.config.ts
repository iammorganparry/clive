import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "node:path";
import { fileURLToPath } from "node:url";
import fs from "node:fs";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const ROUTERS_DIR = path.resolve(__dirname, "src/rpc/routers");

/**
 * Convert a filename to a router name (camelCase).
 * e.g., "knowledge-base.ts" -> "knowledgeBase"
 */
function fileNameToRouterName(fileName: string): string {
  const baseName = fileName.replace(/\.ts$/, "");
  return baseName.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Discover all router files in the routers directory.
 * Returns an array of { name, filePath } sorted alphabetically by name.
 */
function discoverRouters(): Array<{ name: string; filePath: string }> {
  const files = fs.readdirSync(ROUTERS_DIR);
  return files
    .filter((file) => file.endsWith(".ts") && !file.startsWith("__"))
    .map((file) => ({
      name: fileNameToRouterName(file),
      filePath: path.join(ROUTERS_DIR, file),
    }))
    .sort((a, b) => a.name.localeCompare(b.name));
}

/**
 * Parse a router source file to extract procedure names and types.
 * Looks for patterns like:
 *   procedureName: procedure.input(...).query(
 *   procedureName: procedure.input(...).mutation(
 *   procedureName: procedure.input(...).subscription(
 */
function parseRouterFile(
  filePath: string,
): Array<{ name: string; type: "query" | "mutation" | "subscription" }> {
  const content = fs.readFileSync(filePath, "utf-8");
  const procedures: Array<{
    name: string;
    type: "query" | "mutation" | "subscription";
  }> = [];

  // Match procedure definitions by looking for the pattern:
  // word: procedure[anything].query/mutation/subscription(
  // Using a simpler approach: find .query(, .mutation(, .subscription( and look back for the property name
  const procedureRegex =
    /(\w+):\s*procedure[\s\S]*?\.(query|mutation|subscription)\s*\(/g;

  let match = procedureRegex.exec(content);
  while (match !== null) {
    procedures.push({
      name: match[1],
      type: match[2] as "query" | "mutation" | "subscription",
    });
    match = procedureRegex.exec(content);
  }

  return procedures;
}

/**
 * Generate the router shape content from source files.
 */
function generateRouterShapeContent(): string {
  const routers = discoverRouters();
  const routerEntries = routers
    .map(({ name: routerName, filePath }) => {
      const procedures = parseRouterFile(filePath);
      const procedureLines = procedures
        .map((p) => `    ${p.name}: createProcedureShape("${p.type}"),`)
        .join("\n");
      return `  ${routerName}: {\n${procedureLines}\n  },`;
    })
    .join("\n");

  return `// AUTO-GENERATED - DO NOT EDIT
// Generated by vite.config.ts during webview build
// To update, modify the routers in src/rpc/routers/ and rebuild

import type { RouterRecord, Procedure } from "@clive/webview-rpc";

function createProcedureShape<T extends "query" | "mutation" | "subscription">(
  type: T,
): Procedure<unknown, unknown, unknown, T> {
  return {
    _def: {
      type,
      input: undefined,
      output: undefined,
      context: undefined,
    },
  } as Procedure<unknown, unknown, unknown, T>;
}

export const routerShape: RouterRecord = {
${routerEntries}
};
`;
}

/**
 * Vite plugin to generate router-shape.ts from router source files before build.
 * This ensures the webview RPC client shape stays in sync with the actual router.
 */
function generateRouterShapePlugin() {
  return {
    name: "generate-router-shape",
    buildStart() {
      const content = generateRouterShapeContent();
      const outputPath = path.resolve(
        __dirname,
        "src/webview/rpc/router-shape.ts",
      );
      fs.writeFileSync(outputPath, content);
      console.log("[generate-router-shape] Generated router-shape.ts");
    },
  };
}

export default defineConfig(({ mode }) => {
  // Load env file from the root of the monorepo (two levels up from vite.config.ts)
  // Vite automatically loads .env files from the project root, but in a monorepo
  // we need to explicitly point to the root directory
  const rootDir = path.resolve(__dirname, "../../");
  const _env = loadEnv(mode, rootDir, "VITE_");

  return {
    plugins: [
      generateRouterShapePlugin(),
      tailwindcss(),
      react(),
      {
        name: "remove-html-output",
        writeBundle(options, bundle) {
          // Remove HTML files and src directory since we generate HTML dynamically
          const outDir = options.dir || "dist/webview";

          // Remove HTML files from bundle
          for (const fileName in bundle) {
            if (fileName.endsWith(".html")) {
              delete bundle[fileName];
            }
          }

          // Clean up any HTML files and src directory that were created
          try {
            const htmlPath = path.join(outDir, "src", "webview", "index.html");
            if (fs.existsSync(htmlPath)) {
              fs.unlinkSync(htmlPath);
              // Remove empty directories
              const srcWebviewDir = path.join(outDir, "src", "webview");
              const srcDir = path.join(outDir, "src");
              if (fs.existsSync(srcWebviewDir)) {
                fs.rmSync(srcWebviewDir, { recursive: true });
              }
              if (fs.existsSync(srcDir)) {
                fs.rmSync(srcDir, { recursive: true });
              }
            }
          } catch (_error) {
            // Ignore cleanup errors
          }
        },
      },
    ],
    build: {
      outDir: "dist/webview",
      emptyOutDir: true,
      sourcemap: true,
      rollupOptions: {
        input: path.resolve(__dirname, "src/webview/index.html"),
        output: {
          format: "iife", // Output as IIFE, not ES module
          chunkFileNames: "webview-[hash]-[name].js",
          entryFileNames: "webview.js",
          assetFileNames: (assetInfo) => {
            if (assetInfo.name?.endsWith(".css")) {
              return "webview.css";
            }
            // Keep original name for other assets
            return assetInfo.name || "asset";
          },
        },
      },
    },
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "src"),
      },
    },
    // Configure Vite to load .env files from monorepo root
    envDir: rootDir,
    // Explicitly define env variables using the loaded env values
    // This ensures they're available in the built bundle
  };
});
